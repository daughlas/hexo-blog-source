---
title: 异步操作
date: 
categories:
- Node
tags:
- Node.js
---

## 异步操作

1. 当代码需要等待一个无状态的东西的时候，比如说不知道用户什么时候输入
2. 异步的就是执行要好长时间的代码，我们直接绕过它
3. JS 代码计时器

```JavaScript
console.time("main");
// 执行一段代码
console.timeEnd("main");
```

4. 手动写异步的操作用 `setTimeout([function],0)` 实现
5. callback 一般都是错误优先的回调函数，异步操作发生异常的话，外界是捕获不到的。错误优先的回调函数，如下

```javascript
function doSomethingAsync (path, callback) {
  if (错误) {
    callback(new Error('xxx 错误'))    
  } else {
    callback(null, data);
  }
}
```

6. 典型的异步操作
   1. 打电话是同步操作，发短信是异步操作
   2. 程序世界中：定时器、Ajax、文件操作 是典型的异步的。
   3. Node.js 所有的会发生阻塞的操作都是异步的，主要是文件操作和网络操作
7. I/O：可以理解为从输入到输出之间的转化过程
8. 对于耗费时间的任务 Node.js 把这个任务和任务执行完的回调函数，下达给了操作系统（这么理解），放在任务队列（Event Loop）的最后一个，让它去执行
9. 效率最高：专注于做一件事，这件事做完之后马上再去做另外一件事情。
10. 由于 Windows 和 *nix 平台的差异，Node 提供了libuv 作为抽象封装层，保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立

## 非阻塞的优势

1. 提高代码的响应效率
2. 充分利用单核CPU
3. 改善I/O的不可预测带来的问题
4. 但是目前市面上大多数都是多核 CPU，不能很好利用多核，一般运用虚拟化技术把多核 CPU 虚拟城单核机

## 单线程

12. 进程和线程 
    1. 进程是一个更大的单位，线程更小
    2. 进程：每一个**正在运行**的应用程序都至少有一个进程，它给应用程序提供运行环境，是操作系统为应用程序分配资源的一个单位。
    3. 线程：用来执行代码，一个进程内部可以有很多线程，一个线程同时只能干一件事情
    4. 传统的开发方式大部分的I/O都是阻塞的，小更多的线程来更好的利用硬件资源
    5. 多线程的缺点
       1. 线程之间共享某些数据，同步起来很麻烦
       2. 更致命的是：（主要单核CPU的问题，伪多线程）
          1. 创建线程耗费
          2. 线程数量有限，线程初始化空间 2M 已经很大了，这个占得是内存
          3. 虽然多线程，但是还是只有一个CPU
          4. CPU 在不同线程之间转换，有个上下文转换，非常耗费时间。（Node最大的性能优势）
    6. 例如： node 进程启动之后，会默认创建一个线程，用于执行我们的代码，一般是叫main thread。
13. 在chrome 的控制台中，按shift + return 可以换行写代码。
14. 异步回调的问题：嵌套过深；回调黑洞（里层调用外层内容，形成死循环）。——Promise解决回调嵌套的问题。
    1. 不容易阅读
    2. 不容易调试：断点不容易打
    3. 不容易维护：加一个功能难
15. V8 引擎的一个最主要特点就是单线程

---

## 事件驱动和非阻塞，Node.js 如何利用单线程

1. Node.js 主线程之外，内部有一个事件队列
2. Node 的执行过程有一个事件循环，事件循环回去判断是不是有阻塞操作，阻塞的就安排到 Node 底层的 Thread Pool 线程池中
3. 所以对于编程Node是单线程的，实际底层运行的时候它还是多线程的，用多线程来执行那些阻塞的操作。
4. 为了避免线程创建耗费资源 Node 的多线程是实现创建好，放在 THread Pool 中的。
5. 专业一点的表述
   1. Node平台将一个任务联通该任务的回调函数放到一个事件循环系统中；
   2. 事件循环高效的管理系统线程池同时高效执行每一个任务
   3. 当任务完成过后自动执行回调函数
   4. Node 将所有的阻塞操作交给了内部实现的线程池
   5. Node.js 本身主线程主要就是不断地往返调度