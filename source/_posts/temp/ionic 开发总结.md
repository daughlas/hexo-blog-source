---
title:  ionic 开发总结
date: 
categories:
- 临时
tags:
- 临时
---
#### 各种命令

ionic serve -lc，ionic提供的浏览器调试

ionic g page xxx，添加模版页面

引入`import {NavParams} from 'ionic-angular'`
 跳转时传入参数： `this.navCtrl.push(demoPage, {item: 'value'})`
 跳转后的页面通过get方法获取值: `let temp = this.navParams.get('item')`



#### gradle 配置

-  `ionic build android`是通过gradle编译，而且会在线下载gradle，墙内基本是下不了的，这就需要手动下载项目需要的gradle版本。 查看android platform下的build.gradle文件，看当前版本需要的gradle version。 下载成功后，放在`myApp\platforms\android\gradle`文件夹下， 命令行输入`set CORDOVA_ANDROID_GRADLE_DISTRIBUTION_URL=../gradle-2.14.1-all.zip` 
- maven下载失败问题。替换为阿里云镜像：
   打开项目\platforms\android\build.gradle修改：



#### Ionic2引入第三方js库（未验证）

应用中想实现一个页面，进入时显示根据设备uuid生成的二维码，虽然barcodescanner可以实现生成二维码，但会打开一个Activity，这样体验不符合需求。于是想到引用第三方的js库，如qrcode.js等。
 然而Ionic2使用typescript，ts中是无法直接调用js的。这里网上给出了两种方案。

1. 引入js文件，通过declarations.d.ts文件声明引用变量。
2. 通过types库下载qrcode。

方案2并没有成功，方案1的具体过程以qrcode为例，如下：

1. 从github下在需要的js文件，`jquery.min.js`和`qrcode.js` 
2. 文件复制到项目'/src/assets/js'目录下，js目录是自己新建的
3. 在index.html中引入：
    `<script src="assets/js/jquery.min.js"></script> <script src="assets/js/qrcode.min.js"></script>` 
4. 在src目录下的`declarations.d.ts`中申明qrcode的方法变量：
    `declare var QRCode;` 
5. 完成以上步骤后，就可以在ts中调用qrcode的方法，例如在页面上显示一个文本转换的二维码：
    `<div id="qrImage" class="qrcode-image"></div>`
    `let qrImage = document.getElementById('qrImage'); new QRCode(qrImage, 'test');`



 #### 修改应用名称

修改根目录下config.xml文件： `<widget id="com.ionframework.demo">`，id对应应用的包名

 `<name></name>`对应应用名称，直接修改Android的values文件没有效果



#### 解决Splash后出现短暂白屏问题

修改config.xml：
添加 `<preference name="AutoHideSplashScreen" value="false"/>`
注释掉 `<preference name="SplashScreenDelay" value="3000"/>`



#### 签名和打包

###### 打包

ionic （cordova） build android —prod  -release 打包

###### 生成密钥

首先打开终端，cd该路径，输入命令 `keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore` 

参数解释：`-genkey` 产生密钥，`-alias demo.keystore` 别名 demo.keystore，`-keyalg RSA` 使用RSA算法对签名加密，`-validity 40000` 有效期限4000天，-keystore demo.keystore

###### 签名

这里有两种方案，一个是通过jarsigner工具，另一个是通过Ionic自动签名。这里笔者使用第二种。

 在项目的/platforms/android/目录下新建`release-signing.properties`文件，添加内容：

```
storeFile=path to keystore
keyAlias=your key alias
storePassword=your store password
keyPassword=you key password
```

 

####获取设备分辨率

`window.screen.width * window.devicePixelRatio; window.screen.height * window.devicePixelRatio;`



 #### 页面间的参数传递

引入`import {NavParams} from 'ionic-angular'`
 跳转时传入参数： `this.navCtrl.push(demoPage, {item: 'value'})`
 跳转后的页面通过get方法获取值: `let temp = this.navParams.get('item')`



 #### 生命周期

| 事件名称          | 事件说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| ionViewDidLoad    | 页面加载完毕出发。页面被创建DOM的时候触发，如果页面被缓存，就不会再次出发了。可以放置一些初始化页面的事件。 |
| ionViewWillEnter  | 即将进入一个页面变成当前激活页面的时候执行                   |
| ionViewDidEnter   | 进入了一个页面，并且页面变成了当前激活的页面，不管第一次进入页面还是缓存后进入都会执行 |
| ionViewWillLeave  | 将要离开页面的时候执行                                       |
| ionViewDidLeave   | 完成离开页面之后执行                                         |
| ionViewWillUnload | 页面销毁和页面中所有元素移除之前执行                         |
| ionViewDidUnload  | 页面销毁和页面中有元素移除之后执行的事件                     |

### 热更新的方法

1. 安装 cordova-hot-code-push-cli,执行命令 `npm install -g cordova-hot-code-push-cli`，作用是使用该命令行生成检测配置文件，通常是在 `www` 目录下动态生成 `chcp.json`和 `chcp.manifest` 生成两个文件

2. 进入项目目录

3. 安装热更新插件，执行命令(cordova或ionic都可以)：`cordova/ionic plugin add cordova-hot-code-push-plugin`

4. **创建cordova-hcp.json模板**

   在cordova项目根目录下创建一个 cordova-hcp.json模板文件。 cordova-hcp.json内容如下：

   ```
   {
     "autogenerated": true,
     "name": "bankapp",
     "min_native_interface": 1, //最小支持的外壳app版本
     "content_url": "http://192.168.1.101:9999/www",
     "ios_identifier":"https://itues.apple.com/cn/***", //打版提交App Store下载的地址
     "update": "now"
   }
   ```

   **&注意** ：content_url：是你服务器上要更新的文件地址，执行： `$ cordova-hcp build`，就会利用这个模板自动在`www`文件夹下生成新的 chcp.json和chcp.manifest文件，而不用手动更改 www/chcp.json了。

   解析下：

   - min_native_interface: 记录当前App的外壳版本值
   - chcp.manifest文件记录版本的hash值
   - ios_identifier:记录App在苹果商店上的位置，就是外壳地址
   - release：内壳时间戳版本，根据时间戳来更新的。
   - content_url: 是你服务器内更新的文件地址。此处建议设为www文件夹，因为我们改动代码后要把www文件进行更新，可以直接将改动后的www文件夹把服务器上旧的的www替换掉。

5.  配置config.xml文件

   在config.xml文件中添加以下代码: 

   ```
   <chcp> <native-interface version="1" /> <config-file url="http://192.168.1.101:9999/www/chcp.json" /> </chcp>
   ```

   **&注意：**url为你服务器中更新文件的地址/ chcp.json

   **&注意：**内壳更新 要把cordova-hcp.json和config.xml中的 版本号设置为一样的

6. **完成以上准备，开始测试 热更新(html、css或js等资源的动态更新，即内壳更新）**

7. 更改文件以后运行 `$ cordova-hcp build`，再次将更改后的www的文件拷贝到服务器中，把原来旧的www文件替换即可

参考资料： https://www.jianshu.com/p/2f356e3276b8



#### 外壳更新 （从网上抄的）

#### 描述

这个外壳更新有点强制化，比如你在使用应用时，突然弹出个pop,提示你有新的版本更新了，人性化点的还有个取消按钮；强制性的就确定后直接跳转到AppStore了。这在你自己怎么设置了。
 像原生的版本更新就没有强制；如你打版提交审核上架了，客户端也就仅在appStore商店有个更新提醒，更不更在客户了。

#### 外壳更新配置

上面的内壳更新整好后，这就比较简单了，因该配的已配置好，只在这改改某些属性就可以

##### 通过min_native_interface监控app是否提示更新

所需最小的外壳app版本. 这是app的build版本号，是个整型数字, 不是应用商店中看到的形如”1.0.0”字符串。

在 config.xml中，这样指定build版本号，例如：app外壳里的config.xml是这样的：

```
    <chcp>
        <native-interface version="1" />
        <config-file url="http://192.168.191.2:9999/www/chcp.json" />
    </chcp>
```

与www目录下的cordova-hcp.json/chcp.json里面的min_native_interface数值相对应，

> 若服务器里的min_native_interface也对应是1，就不会出现提示用户升级版本的状态（即外壳更新），正常修改www目录的内容通过更新release值，和客户端进行对比，可实现热更新（即内壳更新）。

```
{
  "autogenerated": true,
  "name": "bankapp",
  "min_native_interface": 1, //最小内核版本号
  "content_url": "http://192.168.191.2:9999/www",
  "ios_identifier": "https://itues.apple.com/cn/***", //打版提交App Store下载的地址
  "update": "now",
  "release": "2017.02.23-12.53.32"
}
```

假设你的外壳app加了个新的插件或文件，应该会更新外壳app。为了防止用户通过热更新下载了不适合他现有外壳app的web内容，应该设置下 min_native_interface 的值
 下面我们将 min_native_interface 的值改为 2

```
{
  "autogenerated": true,
  "name": "bankapp",
  "min_native_interface": 2, //最小支持的外壳app版本
  "content_url": "http://192.168.191.2:9999/www",
  "ios_identifier": "https://itues.apple.com/cn/***", //打版提交App Store下载的地址
  "update": "now",
  "release": "2017.02.23-12.53.32"
}
```

热更新插件加载到这段json的时候, 发现 min_native_interface 比当前外壳app的build号要大，便不会下载web内容。而是触发一个chcp_updateLoadFailed 错误通知, 告诉用户需要升级外壳app版本了。

此属性将与config.xml中的native-interface进行对比，如果发现两者不同时，将会触发相应的事件，比如，手机端app中config.xml的`native-interface`值比服务器上的chcp.json文件中的`min_native_interface`值小时，将会触发`’chcp_updateLoadFailed’`事件，同时，错误代码为：
 `chcp.error.APPLICATION_BUILD_VERSION_TOO_LOW` 通过这个错误码调用js端监听相应事件通过弹窗提示用户去升级，跳转到AppStore或下载新安装包。

> #### 具体步骤
>
> 1、导入插件。外壳（版本号）的更新需要导入另外3个插件
>  [cordova-plugin-file](https://link.jianshu.com?t=https://github.com/apache/cordova-plugin-file)、[cordova-plugin-file-transfer](https://link.jianshu.com?t=https://github.com/apache/cordova-plugin-file-transfer)、[cordova-plugin-file-opener2](https://link.jianshu.com?t=https://github.com/pwlin/cordova-plugin-file-opener2)

> 导入命令：```
>  $ cordova plugin add cordova-plugin-file
>  $ cordova plugin add cordova-plugin-file-transfer
>  $ cordova plugin add cordova-plugin-file-opener2

```
> 2、添加代码-弹框-跳转至商店更新 **& ios_identifier为要跳转的地址**
> 将下面的代码放到 .run function中启动时就调用（看自己怎么封装的，我封到router中了）如图:
> ![](http://upload-images.jianshu.io/upload_images/4665802-c8d20aa8c0413f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 
 `min_native-interface`将与config.xml中的`native-interface`进行对比、如果两者不同、将会触发`'chcp_updateLoadFailed'`事件。同时、错误代码为：
`chcp.error.APPLICATION_BUILD_VERSION_TOO_LOW`，返回值为-2，那么就会执行下面的代码，弹框提示更新了。

>  ```
var appUpdate = {
        // Application Constructor
        initialize: function() {
            this.bindEvents();
        },
        // Bind any events that are required.
        // Usually you should subscribe on 'deviceready' event to know, when you can start calling cordova modules
        bindEvents: function() {
            document.addEventListener('deviceready', this.onDeviceReady, false);
            document.addEventListener('chcp_updateLoadFailed', this.onUpdateLoadError, false);
        },
        // deviceready Event Handler
        onDeviceReady: function() {
        },
        onUpdateLoadError: function(eventData) {
            var error = eventData.detail.error;
            
            // 当检测出外核版本有更新，// 针对不同平台进行相应更新操作
            if (error && error.code == chcp.error.APPLICATION_BUILD_VERSION_TOO_LOW) {
                var dialogMessage = '有新的版本,请下载更新';
                
                // iOS端 直接弹窗提示升级，点击ok后自动跳转
                if(ionic.Platform.isIOS()){
                    chcp.requestApplicationUpdate(dialogMessage, this.userWentToStoreCallback, this.userDeclinedRedirectCallback);
                //Android端 提示升级下载最新APK文件 
                } else if(ionic.Platform.isAndroid()){
                    //这儿放Android端更新代码...，在下面👇
                }
            }
        },
        userWentToStoreCallback: function() {
            // user went to the store from the dialog
        },
        userDeclinedRedirectCallback: function() {
            // User didn't want to leave the app.
            // Maybe he will update later.
        }
    };
    appUpdate.initialize();
```

**Android端添加代码👆 提示升级下载最新APK文件**

>  

```
var confirmPopup = $ionicPopup.confirm({
  template: '有新的版本,请下载更新',
  cssClass: 'popup',
  cancelText:'取消',
  okText:'升级'
});
confirmPopup.then(function (res) {
  if (res) {
    $ionicLoading.show({
      template: "已经下载：0%"
    });
    window.resolveLocalFileSystemURL(cordova.file.externalRootDirectory, function(fileEntry) {
      fileEntry.getDirectory("***(app名称)", { create: true, exclusive: false }, function (fileEntry) {
        //下载代码
        var fileTransfer = new FileTransfer();
        fileTransfer.download("app下载地址", fileEntry.toInternalURL()+"***(app名称).apk", function(entry) {
          // 打开下载下来的APP
          cordova.plugins.fileOpener2.open(
            entry.toInternalURL(),//下载文件保存地址
            'application/vnd.android.package-archive', {//以APK文件方式打开
              error: function(err) {
              },
              success: function() {}
            });
        }, function(err) {
        },true);
        fileTransfer.onprogress = function(progressEvent) {
          $timeout(function () {
            var downloadProgress = (progressEvent.loaded / progressEvent.total) * 100;
            $ionicLoading.show({
              template: "已经下载：" + Math.floor(downloadProgress) + "%"
            });
            if (downloadProgress > 99) {
              $ionicLoading.hide();
            }
          });
        };
      },function(err){alert("创建失败")});
    });
  }
});
```

##### chcp.json中update字段含义

指定了什么时候安装web内容更新，支持的值有：

> start  - app启动时安装更新，默认值
>  resume - app从后台切换过来的时候安装更新
>  now    - web内容下载完毕即安装更新

好了，先总结这么多，可能会有些细节落下，望大家参考时，给我提下，我在继续补充。

 

 

 

 

 