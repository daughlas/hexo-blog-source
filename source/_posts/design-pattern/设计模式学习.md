---
title:  设计模式学习
date: 
categories:
- 设计模式
tags:
- imooc 实战
---

# 设计模式

设计模式的核心操作是去观察你整个逻辑里面的**变与不变**，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。

## 1 构造器模式（创建型）

构造器解决的是多个对象实例的问题

未使用

```javascript
const liLei = {
    name: '李雷',
    age: 25,
    career: 'coder',
}

const hanMeiMei = {
    name: '韩梅梅',
    age: 24,
    career: 'product manager'
}
```

使用

```javascript
function User(name, age, career) {
	this.name = name
	this.age = age
	this.career = career
}

var liLei = new User('李雷', 25, 'coder')
var hanMeiMei = new User('韩梅梅', 24, 'product manager')
```

在创建一个user过程中，谁变了，谁不变？很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的**个性**，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的**共性**。

那么构造器做了什么？构造器是不是将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了**共性**的不变，同时将 name、age、career 各自的取值操作开放，确保了**个性**的灵活？

如果在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。那么使用工厂模式时，我们要做的就是去抽象不同构造函数（类）之间的变与不变。



## 2 工厂模式（创建型）

### 2.1 简单工厂

单工厂解决的是多个类的问题。

有构造函数的地方，我们就应该想到简单工厂；在写了大量构造函数、调用了大量的 new、自觉非常不爽的情况下，我们就应该思考是不是可以掏出工厂模式。

未使用：

```javascript
function Coder(name, age) {
	this.name = name
	this.age = age
	this.career = 'coder'
	this.work = ['写代码', '写测试', '修bug']
}
function ProductManager(name, age) {
	this.name = name
	this.age = age
	this.career = 'product manager'
	this.work = ['订会议室', '写PRD', '催更']
}

function Factory(name, age, career) {
	switch(career) {
		case 'coder':
			return new Coder(name, age)
			break
    case 'product manager':
    	return new ProductManager(name, age)
    	break
    // .......... 可能会很多
	}
}
```

假如我们有一个 500 员工的 Excel 表，我们要创建对象，现在会这么做

抽的更彻底一点，不要写无数个构造函数

使用：

```javascript
function User(name, age, career, work) {
	this.name = name
  this.age = age
  this.career = career 
  this.work = work
}

function Factory(name, age, career) {
	let work
  switch(career) {
		case 'coder':
			work =  ['写代码','写系分', '修Bug'] 
			break
		case 'product manager':
			work = ['订会议室', '写PRD', '催更']
			break
		case 'boss':
			work = ['喝茶', '看报', '见客户']
    case 'xxx':
			// 其它工种的职责分配...
	}
	return new User(name, age, career, work)
}

```

### 2.2 抽象工厂

开放封闭原则的内容：对拓展开放，对修改封闭。说得更准确点，**软件实体（类、模块、函数）可以扩展，但是不可修改**。

```javascript
class MobilePhoneFactory {
  // 提供操作系统的接口
  createOS(){
    throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
  }
  // 提供硬件的接口
  createHardWare(){
    throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！");
  }
}

class FakeStarFactory extends MobilePhoneFactory {
  createOS() {
    return new AndroidOS() // 提供安卓系统实例
  }
  createHardware() {
    return new QualcommHardware() // 提供高通硬件实例
  }
}

class OS {
	controlHardware() {
		throw new Error('抽象产品方法不允许直接调用，你需要将我重写！')
	}
}

class AndroidOS extends OS {
	controlHardware() {
		console.log('我会用安卓的方式去操作硬件')
	}
}

class AppleOS extends OS {
	controlHardware() {
		console.log('我会用苹果的方式去操作硬件')
	}
}

class Hardware {
	operateByOrder() {
		throw new Error('象产品方法不允许直接调用，你需要将我重写！')
	}
}

class QualcommHardware extends Hardware {
	operateByOrder() {
		console.log('我会用高通的方式去运转')
	}
}

class MiWare extends Hardware {
	operateByOrder() {
		console.log('我会用小米的方式运转')
	}
}

const myPhone = new FakeStarFactory()
const myOS = myPhone.createOS()
const myHardware = myPhone.createHardware()
myOS.controlHardware()
myHardware.operateByOrder()
```



## 3 单例模式（创建型）

**保证一个类仅有一个实例，并提供一个访问它的全局访问点**，这样的模式就叫做单例模式。

获取实例方法一：

```javascript
class SingleDog {
	show() {
		console.log('我是一个单例对象')
	}
	getInstance() {
		if (!singleDog.instance) {
			SingleDog.instance = new SingleDog()
		}
		return SingleDog.instance
	}
}
```

获取实例方法二：

```javascript
SingleDog.getInstance = (function() {
	let instance = null
	return function() {
		if (!instance) {
			instance = new SingleDoog()
		}
		return instance
	}
})()
```

指向了唯一的实例

```javascript
const s1 = SingleDog.getInstance()
const s2 = SingleDog.getInstance()
s1 === s2 // true
```



```javascript
let Vue // 这个Vue的作用和楼上的instance作用一样

export function install (_Vue) {
  // 判断传入的Vue实例对象是否已经被install过Vuex插件（是否有了唯一的state）
  if (Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      )
    }
    return
  }
  // 若没有，则为这个Vue实例对象install一个唯一的Vuex
  Vue = _Vue
  // 将Vuex的初始化逻辑写进Vue的钩子函数里
  applyMixin(Vue)
}
```



## 4 原型模式

原型模式不仅是一种设计模式，它还是一种**编程范式**（programming paradigm），是 JavaScript 面向对象系统实现的根基。

原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过**克隆原型**的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，`Object.create`方法就是原型模式的天然实现——准确地说，只要我们还在借助`Prototype`来实现对象的创建和原型的继承，那么我们就是在应用原型模式。

```javascript
class Dog {
	constructor(name, age){
		this.name = name
		this.age = age
	}
	eat() {
		console.log('吃')
	}
}

// 上下两个是一样的
function Dog(name, age) {
	this.name = name
	this.age = age
}
Dog.prototype.eat = function() {
	console.log('吃')
}
```

在 JavaScript 中，每个构造函数都拥有一个`prototype`属性，它指向构造函数的原型对象，这个原型对象中有一个 construtor 属性指回构造函数；

每个实例都有一个`__proto__`属性，当我们使用构造函数去创建实例时，实例的`__proto__`属性就会指向构造函数的原型对象。

```javascript
function Dog(name, age) {
  this.name = name
  this.age = age
}

Dog.prototype.eat = function() {
  console.log('肉骨头真好吃')
}

const dog = new Dog('旺财', 3)

console.log(Dog.prototype.constructor === Dog)
console.log(dog.__proto__ === Dog.prototype)
```



## 5 装饰器模式

不仅麻烦，直接去修改已有的函数体，这种做法违背了我们的“开放封闭原则”；往一个函数体里塞这么多逻辑，违背了我们的“单一职责原则”。所以说这个事儿，越想越不能这么干。

老代码

```javascript
<body>
	<button id='open'>点击打开</button>
	<button id='close'>关闭弹框</button>
</body>
<script>
const Modal = (function() {
	let modal = null
	return function() {
		if(!modal) {
			modal = document.createElement('div')
			modal.innerHTML = '您还未登录哦~'
      modal.id = 'modal'
      modal.style.display = 'none'
      document.body.appendChild(modal)
		}
		return modal
	}
})()

// 点击打开按钮展示模态框
document.getElementById('open').addEventListener('click', function() {
	// 未点击则不创建modal实例，避免不必要的内存占用
	const modal = new Modal()
	modal.style.display = 'block'
})

// 点击关闭按钮隐藏模态框
document.getElementById('close').addEventListener('click', function() {
	const modal = document.getElementById('modal')
	if(modal) {
		modal.style.display = 'none'
	}
})

</script>
```

新代码，先把老的逻辑抽出去，再加自己的新逻辑

```javascript
<script>
function openModal() {
	const modal = new Modal()
  modal.style.display = 'block'
}
// 按钮文案修改逻辑
function changeButtonText() {
  const btn = document.getElementById('open')
  btn.innerText = '快去登录'
}

// 按钮置灰逻辑
function disableButton() {
  const btn =  document.getElementById('open')
  btn.setAttribute("disabled", true)
}

// 新版本功能逻辑整合
function changeButtonStatus() {
  changeButtonText()
  disableButton()
}

document.getElementById('open').addEventListener('click', function() {
  openModal()
  changeButtonStatus()
})
</script>
```

再改一版，用 ES6 来写

```javascript
class OpenButton {
	onClick() {
		const modal = new Modal()
		modal.style.display = 'block'
	}
}

class Decorator {
	constructor(open_btn) {
		this.open_btn = open_btn
	}
	
	onClick() {
		this.open_btn.onClick()
		this.changeButtonStatus()
	}
	
	changeButtonStatus() {
		this.changeButtonText()
		this.disableButton()
	}
	
	disableButton() {
		const btn = document.getElementById('open')
		btn.setAttributes('disabled', true)
	}
	
	changeButtonText() {
		const btn = document.getElementById('open')
		btn.innerText = '快去登录'
	}
}

const openButton = new OpenButton()
const decorator = new Decorator(openButton)

document.getElementById('open').addEventListener('click', function() {
    // openButton.onClick()
    // 此处可以分别尝试两个实例的onClick方法，验证装饰器是否生效
    decorator.onClick()
})
```

### 单一职责原则

大家可能刚刚没来得及注意，按钮新逻辑中，文本修改&按钮置灰这两个变化，被我封装在了两个不同的方法里，并以组合的形式出现在了最终的目标方法`changeButtonStatus`里。这样做的目的是为了强化大家脑中的“单一职责”意识。将不同的职责分离，可以做到每个职责都能被灵活地复用；同时，不同职责之间无法相互干扰，不会出现因为修改了 A 逻辑而影响了 B 逻辑的狗血剧情。



### ES7 之中的装饰器

#### 装饰类

```javascript
function classDecorator(target) {
	target.hasDecorator = true
	return target
}

@classDecorator
class Button {}

console.log('Button 是否被装饰了：', Button.hasDecorator)
```

### 装饰类之中的方法

```javascript
function funcDecorator(target, name, descriptor) {
	let originalMethod = descriptor.value
	descriptor.value = function() {
		console.log('这是 Func 的装饰器逻辑')
		return originalMethod.apply(this, arguments)
	}
	return descriptor
}

class Button {
	@funcDecorator
	onClick() {
		console.log('这是 Func 的原有逻辑')
	}
}

const button = new Button()
button.onClick()
```

参数说明和注意事项

* target 表示 Button.prototype，即累的原型对象
* name 装饰目标的属性名，比如 onClick
* descriptor 属性描述对象
  * 数据描述符
    * value，默认 undefined
    * writalbe，默认 true
    * enumerable，是否可枚举，默认 true
    * configurable，是否可配置，默认 true
  * 存取描述符
    * get 访问属性时调用的方法
    * set 设置属性时调用的方法
* 装饰器函数执行的时候，Button 实例并不存在，实例实在我们的代码运行时动态生成的，而装饰器函数则是在函数编译阶段就执行了。

要想使用装饰器

```javascript
npm install babel-preset-env babel-plugin-transform-decorators-legacy --save-dev
npm install babel-cli -g
```

> 编写配置文件 .babelrc

```javascript
{
  "presets": ["env"],
  "plugins": ["transform-decorators-legacy"]
}
```





## 6 结构型：适配器模式

适配器模式通过**把一个类的接口变换成客户端所期待的另一种接口**，可以帮我们解决**不兼容**的问题。

实际接口和目标接口不匹配的尴尬可以用一个叫适配器的东西来化解。

新代码

```javascript
export default class HttpUtils {
	static get(url) {
		return new Promsie((resolve, reject) => {
			fetch(url)
				.then(response => response.json())
				.then(result => {
					resolve(result)
				})
				.catch(error => {
					reject(error)
				})
		}
	}
	
	static post(url, data) {
		fetch(url, {
			method: 'POST,
			headers: {
				'Accept': 'application/json',
				'Content-Type': 'application/x-ww-form-urlencoded'
			},
			body: this.changeData(data)
		})
			.then(response => response.json())
      .then(result => {
      	resolve(result)
      })
      .catch(error => {
      	reject(error)
      })
	}
	
	static changeData(obj) {
		var prop
		var str = ''
		var i = 0
		for (prop in obj) {
			if (!prop) {
				return
			}
			if (i== 0) {
				str += prop + '=' + obj[prop]
			} else {
				str += '&' + prop + '=' + obj[prop]
			}
			i++
		}
		return str
	}
}

const URL = 'ZZCVXSDASD'
const params = {a: 'b', c: 'd'}

const postResponse = awaitHttpUtils.post(URL, params) || {}
const getResponse = await HttpUtils.get(URL)
```

老代码

```javascript
function Ajax(type, url, data, success, failed){
	// 创建ajax对象
  var xhr = null;
  if(window.XMLHttpRequest){
  	xhr = new XMLHttpRequest();
  } else {
  	xhr = new ActiveXObject('Microsoft.XMLHTTP')
  }
  
   ...(此处省略一系列的业务逻辑细节)
   var type = type.toUpperCase();
    
  // 识别请求类型
  if(type == 'GET'){
  	if(data){
    	xhr.open('GET', url + '?' + data, true); //如果有数据就拼接
    } 
    // 发送get请求
    xhr.send();
  } else if(type == 'POST'){
  	xhr.open('POST', url, true);
    // 如果需要像 html 表单那样 POST 数据，使用 setRequestHeader() 来添加 http 头。
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    // 发送post请求
    xhr.send(data);
  }
  
  // 处理返回数据
  xhr.onreadystatechange = function(){
  	if(xhr.readyState == 4){
    	if(xhr.status == 200){
      	success(xhr.responseText);
      } else {
      	if(failed){
        	failed(xhr.status);
        }
      }
    }
  }
}

// 发送get请求
Ajax('get', url地址, post入参, function(data){
    // 成功的回调逻辑
}, function(error){
    // 失败的回调逻辑
})
```

适配器一下

```javascript
async function AjaxAdapter(type, url, data, success, failed) {
	const type = type.toUpperCase()
	let result
	try {
		if (type === 'GET') {
      result = await HttpUtils.get(url) || {}
    } else {
      result = await HttpUtils.post(url, data) || {}
    }
    result.statusCode === 1 && success ? success(result) : failed(result.statusCode)
	} catch(error) {
		// if (failed) {
			failed(error.statusCode)
		}
	}
}

// 用适配器适配旧的Ajax方法
async function Ajax(type, url, data, success, failed) {
    await AjaxAdapter(type, url, data, success, failed)
}
```



## 7 结构型：代理模式

代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象**不能直接访问**另一个对象，需要一个**第三者**（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。

为了屏蔽某些网站，一股神秘的东方力量会作用于你的 DNS 解析过程，告诉它：“你不能解析出xxx.xxx.xxx.xxx（某个特殊ip）的地址”。而我们的 Google.com，不幸地出现在了这串被诅咒的 ip 地址里，于是你的 DNS 会告诉你：“对不起，我查不到”。

 A 不能直接访问 B，A 需要借助一个帮手来访问 B，这个帮手就是代理器。需要代理器出面解决的问题，就是代理模式发光发热的应用场景。

### 一家小型婚介所的发家致富之路

```javascript
// 未知妹子
const girl = {
  name: '小美', // 姓名
  aboutMe: '...' // 自我介绍（大家自行脑补吧）
  age: 24, // 年龄
  career: 'teacher', // 职业
  fakeAvatar: 'xxxx' // 假头像(新垣结衣的图片地址）
  avatar: 'xxxx' // 真实头像(自己的照片地址),
  phone: 123456, // 手机号
  presents: [], // 礼物数组
  bottomValue: 50, // 拒收50块以下的礼物
  lastPresent: present  // 记录最近一次收到的礼物
}

// 规定礼物的数据结构由type和value组成
const present = {
  type: '巧克力',
  value: 60,
}


// 普通私密信息
const baseInfo = ['age', 'career']
// 最私密信息
const privateInfo = ['avatar', 'phone']

// 用户（同事A）对象实例
const user = {
  // ...(一些必要的个人信息)
  isValidated: true,
  isVIP: false,
}

// 掘金婚介所登场了
const JuejinLovers = new Proxy(girl, {
  get: function(girl, key) {
    if(baseInfo.indexOf(key)!==-1 && !user.isValidated) {
      alert('您还没有完成验证哦')
      return
    }
    //...(此处省略其它有的没的各种校验逻辑)
    
		// 此处我们认为只有验证过的用户才可以购买VIP
    if(user.isValidated && privateInfo.indexOf(key) && !user.isVIP) {
      alert('只有VIP才可以查看该信息哦')
      return
    }
  },
  set: function(girl, key, val) {
    if (key === 'lastPresent') {
      if (val.value < girl.bottomValue) {
        alert('sorry，您的礼物被拒收了')
        return
      }
      
      // 如果没有拒收，则赋值成功，同时并入presents数组
      girl[lastPresent] = val
      girl[presents] = [...presents, val]
    }
	}
})
```

### 代理模式在前端工作之中的应用实践

#### 事件代理

```html
<div id="father">
  <a href="#">链接1号</a>
  <a href="#">链接2号</a>
  <a href="#">链接3号</a>
  <a href="#">链接4号</a>
  <a href="#">链接5号</a>
  <a href="#">链接6号</a>
</div>
```

不适用代理

```javascript
var aNodes = document.getElementById('father').getElementsByTagName('a')
var aLength = aNodes.length
for(var i=0;i<aLength;i++) {
  (function(i) {
    aNodes[i].addEventListener('click', function(e) {
      e.preventDefault()
      alert('我是' + aNodes[i].innerText)
    })
  })(i)
}
```



使用代理

```javascript
const father = document.getElementById('father')

father.addEventListener('click', function(e) {
 if (e.target.tagName === 'A') {
 	e.preventDefault()
 	alert(`我是${e.target.innerText}`)
 }
})
```



#### 虚拟代理

初代代码

```javascript
class PreLoadImage {
	// 展位图 URL
	static LOADING_URL = 'xxxxxx'
	
	constructor(imgNode) {
    this.imgNode = imgNode
  }

	setSrc(targetUrl) {
    this.imageNode.src = PreLoadImage.LOADING_URL
    
    const image = new Image()
    
    image.onload = () => {
      this.imageNode.src = targetUrl
		}
    image.src = targetUrl
	}
}
```

二代，更符合单一原则的代码

```javascript
class PreLoadImage {
	constructor(imageNode) {
		this.imageNode = imageNode
	}
	
	setSrc(imgUrl) {
		this.imageNode.src = imgUrl
	}
}

class ProxyImage {
	static LOADING_URL = 'xxxxxx'
	
	constructor(targetImage) {
		this.targetImage = targetImage
	}
	
	setSrc(targetUrl) {
		this.targetImage.setSrc(ProxyImage.LOADING_URL)
		const virtualImage = new Image()
		virtualImage.onload = () => {
			this.targetImage.setSrc(targetUrl)
		}
		virtualImage.src = targetUrl
	}
}
```

`ProxyImage` 帮我们调度了预加载相关的工作，我们可以通过 `ProxyImage` 这个代理，实现对真实 img 节点的间接访问，并得到我们想要的效果。

在这个实例中，`virtualImage` 这个对象是一个“幕后英雄”，它始终存在于 JavaScript 世界中、代替真实 DOM 发起了图片加载请求、完成了图片加载工作，却从未在渲染层面抛头露面。因此这种模式被称为“虚拟代理”模式。

#### 缓存代理

缓存代理比较好理解，它应用于一些计算量较大的场景里。

这种场景下，我们需要“用空间换时间”——当我们需要用到某个已经计算过的值的时候，不想再耗时进行二次计算，而是希望能从内存里去取出现成的计算结果。

这种场景下，就需要一个代理来帮我们在进行计算的同时，进行计算结果的缓存了。

```javascript
function addAll() {
	console.log('进行了一次计算')
	var i
	var result = 0
	for (i = 0; i < arguments.length; i++) {
		result += arguments[i]
	}
	return result
}

var proxyAdd =  (function () {
	var cache = {}
  return function() {
    var key = Array.prototype.join.call(arguments, ',')
    if (cache[key]) {
      return cache[key]
    } else {
      let result = addAll(...arguments)
      cache[key] = result
      return result
    }
	}
})()

console.log(proxyAdd(1, 2, 3))
console.log(proxyAdd(1, 2, 3))
console.log(proxyAdd(1, 2, 3, 4))
console.log(proxyAdd(1, 2, 3, 4))
```

#### 保护代理

保护某些类中的信息，只暴露一部分。

所谓“保护代理”，就是在访问层面做文章，在 getter 和 setter 函数里去进行校验和拦截，确保一部分变量是安全的。

## 8 行为型：策略模式

### 策略模式之掘金小册

策略模式和状态模式属于本书”彩蛋“性质的附加小节。这两种模式理解难度都不大，在面试中也几乎没有什么权重，但是却对大家培养良好的编码习惯和重构意识却大有裨益。

定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

手实现了算法提取、算法封装、分发优化的整个一条龙的操作流。

#### 业务场景

有一天，产品经理韩梅梅找到李雷，给李雷提了这么个需求：
马上大促要来了，我们本次大促要做差异化询价。啥是差异化询价？就是说同一个商品，我通过在后台给它设置不同的价格类型，可以让它展示不同的价格。具体的逻辑如下：

- 当价格类型为“预售价”时，满 100 - 20，不满 100 打 9 折
- 当价格类型为“大促价”时，满 100 - 30，不满 100 打 8 折
- 当价格类型为“返场价”时，满 200 - 50，不叠加
- 当价格类型为“尝鲜价”时，直接打 5 折

#### if-else 大侠

李雷扫了一眼 prd，立刻来了主意。他首先将四种价格做了标签化：

```
预售价 - pre
大促价 - onSale
返场价 - back
尝鲜价 - fresh
```



```javascript
// 询价方法，接受价格标签和原价为入参
function askPrice(tag, originPrice) {

  // 处理预热价
  if(tag === 'pre') {
    if(originPrice >= 100) {
      return originPrice - 20
    } 
    return originPrice * 0.9
  }
  
  // 处理大促价
  if(tag === 'onSale') {
    if(originPrice >= 100) {
      return originPrice - 30
    } 
    return originPrice * 0.8
  }
  
  // 处理返场价
  if(tag === 'back') {
    if(originPrice >= 200) {
      return originPrice - 50
    }
    return originPrice
  }
  
  // 处理尝鲜价
  if(tag === 'fresh') {
     return originPrice * 0.5
  }
}
```

#### if-else 侠，人人喊打

问题：

* 首先，它违背了“单一功能”原则。一个 function 里面，它竟然处理了四坨逻辑
  * 万一其中一行代码出了 Bug，那么整个询价逻辑都会崩坏
  * 与此同时出了 Bug 你很难定位到底是哪个代码块坏了事
  * 单个能力很难被抽离复用
  * 见到胖逻辑，我们的第一反应，就是一个字——拆！
* 不仅如此，它还违背了“开放封闭”原则。假如有一天韩梅梅再次找到李雷，要他加一个满 100 - 50 的“新人价”怎么办？他只能继续 if-else：

```javascript
 // 处理新人价
  if(tag === 'newUser') {
    if(originPrice >= 100) {
      return originPrice - 50
    }
    return originPrice
  }
```

#### 重构询价逻辑

##### 单一功能改造

```javascript
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

function askPrice(tag, originPrice) {
  // 处理预热价
  if(tag === 'pre') {
    return prePrice(originPrice)
  }
  // 处理大促价
  if(tag === 'onSale') {
    return onSalePrice(originPrice)
  }

  // 处理返场价
  if(tag === 'back') {
    return backPrice(originPrice)
  }

  // 处理尝鲜价
  if(tag === 'fresh') {
     return freshPrice(originPrice)
  }
}
```

OK，我们现在至少做到了一个函数只做一件事。现在每个函数都有了自己明确的、单一的分工。如此一来，我们在遇到 Bug 时，就可以做到“头痛医头，脚痛医脚”，而不必在庞大的逻辑海洋里费力去定位到底是哪块不对。

同时，如果我在另一个函数里也想使用某个询价能力，比如说我想询预热价，那我直接把 prePrice 这个函数拿去调用就是了，而不必在 askPrice 肥胖的身躯里苦苦寻觅、然后掏出这块逻辑、最后再复制粘贴到另一个函数去——更何况万一哪天 askPrice 里的预热价逻辑改了，你还得再复制粘贴一次，扎心啊老铁！

##### 开放封闭改造

那个新人价的问题——这会儿我要想给 askPrice 增加新人询价逻辑，我该咋整？我只能这么来：

```javascript
// 添加一个函数
// 处理新人价
function newUserPrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 50
  }
  return originPrice
}

// 在 askPrice 之中，添加一段代码
// 处理新人价
if(tag === 'newUser') {
	return newUserPrice(originPrice)
}
```

在外层，我们编写一个 newUser 函数用于处理新人价逻辑；在 askPrice 里面，我们新增了一个 if-else 判断。可以看出，这样其实还是在修改 askPrice 的函数体，没有实现“对扩展开放，对修改封闭”的效果。

##### 最终版本

```javascript
// 处理预热价
function prePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 20
  } 
  return originPrice * 0.9
}

// 处理大促价
function onSalePrice(originPrice) {
  if(originPrice >= 100) {
    return originPrice - 30
  } 
  return originPrice * 0.8
}

// 处理返场价
function backPrice(originPrice) {
  if(originPrice >= 200) {
    return originPrice - 50
  }
  return originPrice
}

// 处理尝鲜价
function freshPrice(originPrice) {
  return originPrice * 0.5
}

const priceProcessor = {
	pre: prePrice,
	onSale: onSalePrice,
	back: backPrice,
	fresh: freshPrice
}

function askPrice(tag, originPrice) {
  return priceProcessor[tag](originPrice)
}
```



### 策略模式之慕课网

#### 概念

* 不同策略分开处理
* 避免出现大量 if else 或者 switch case
* JS 未找到经典应用场景，因为主要跟业务有关

#### 示例

```javascript
class User {
	constructor(type) {
		this.type = type
	}
	
	buy() {
		if (this.type === 'ordinary') {
			console.log('普通用户购买')
		} else if (this.type === 'memeber') {
			console.log('会员用户购买')
		} else if (this.type === 'vip') {
			console.log('VIP 用户购买')
		}
	}
}

var u1 = new User('ordinary')
u1.buy()
var u2 = new User('member')
u1.buy()
var u3 = new User('vip')
u1.buy()
```



```javascript
class OrdinaryUser {
	buy() {
		console.log('普通用户购买')
	}
}

class MemberUser {
	buy() {
		console.log('会员用户购买')
	}
}

class VipUser {
	buy() {
  	console.log('VIP 用户购买')
	}
}

var u1 = new OrdinaryUser()
u1.buy()
var u2 = new MemberUser()
u1.buy()
var u3 = new VipUser()
u1.buy()
```

#### 设计原则验证

* 不同策略，分开处理，而不是混合在一起
* 符合开放封闭原则

## 9 行为型：状态模式

### 状态模式之掘金小册

```javascript
- 美式咖啡态（american)：只吐黑咖啡
- 普通拿铁态(latte)：黑咖啡加点奶
- 香草拿铁态（vanillaLatte）：黑咖啡加点奶再加香草糖浆
- 摩卡咖啡态(mocha)：黑咖啡加点奶再加点巧克力
```

初代代码

```javascript
changeState(state) {
  // 记录当前状态
  this.state = state;

  if(state === 'american') {
  	// 这里用 console 代指咖啡制作流程的业务逻辑
  	console.log('我只吐黑咖啡');
  } else if(state === 'latte') {
 		console.log(`给黑咖啡加点奶`);
  } else if(state === 'vanillaLatte') {
  	console.log('黑咖啡加点奶再加香草糖浆');
  } else if(state === 'mocha') {
  	console.log('黑咖啡加点奶再加点巧克力');
  }
}
```

单一职责原则

```javascript
class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  changeState(state) {
    // 记录当前状态
    this.state = state;
    if(state === 'american') {
      // 这里用 console 代指咖啡制作流程的业务逻辑
      this.americanProcess();
    } else if(state === 'latte') {
      this.latteProcress();
    } else if(state === 'vanillaLatte') {
      this.vanillaLatteProcress();
    } else if(state === 'mocha') {
      this.mochaProcress();
    }
  }
  
  americanProcess() {
    console.log('我只吐黑咖啡');    
  }
  
  latteProcress() {
    this.americanProcess();
    console.log('加点奶');  
  }
  
  vanillaLatteProcress() {
    this.latteProcress();
    console.log('再加香草糖浆');
  }
  
  mochaProcress() {
    this.latteProcress();
    console.log('再加巧克力');
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```

开放封闭再改造一下，按照策略模式来

```javascript
const stateToProcessor = {
  american() {
    console.log('我只吐黑咖啡');    
  },
  latte() {
    this.american();
    console.log('加点奶');  
  },
  vanillaLatte() {
    this.latte();
    console.log('再加香草糖浆');
  },
  mocha() {
    this.latte();
    console.log('再加巧克力');
  }
}

class CoffeeMaker {
  constructor() {
    /**
    这里略去咖啡机中与咖啡状态切换无关的一些初始化逻辑
  **/
    // 初始化状态，没有切换任何咖啡模式
    this.state = 'init';
  }
  
  // 关注咖啡机状态切换函数
  changeState(state) {
    // 记录当前状态
    this.state = state;
    // 若状态不存在，则返回
    if(!stateToProcessor[state]) {
      return ;
    }
    stateToProcessor[state]();
  }
}

const mk = new CoffeeMaker();
mk.changeState('latte');
```

但这里有一点大家需要引起注意：这种方法仅仅是看上去完美无缺，其中却暗含一个非常重要的隐患——stateToProcessor 里的工序函数，感知不到咖啡机的内部状况。

#### 策略与状态的辨析

怎么理解这个问题？大家知道，策略模式是对算法的封装。算法和状态对应的行为函数虽然本质上都是行为，但是算法的独立性可高多了。

比如说我一个询价算法，我只需要读取一个数字，我就能啪啪三下五除二给你吐出另一个数字作为返回结果——它和计算主体之间可以是分离的，我们只要关注计算逻辑本身就可以了。

但状态可不一样了。拿咱们咖啡机来说，为了好懂，咱写代码的时候把真正咖啡的制作工序用 console 来表示了。但大家都知道，做咖啡要考虑的东西可太多了。 比如咱们做拿铁，拿铁里的牛奶从哪来，是不是从咖啡机的某个储物空间里去取？再比如我们行为函数是不是应该时刻感知咖啡机每种原材料的用量、进而判断自己的工序还能不能如期执行下去？这就决定了行为函数必须能很方便地拿到咖啡机这个主体的各种信息——它必须得对主体有感知才行。

策略模式和状态模式确实是相似的，它们都封装行为、都通过委托来实现行为分发。
但策略模式中的行为函数是”潇洒“的行为函数，它们不依赖调用主体、互相平行、各自为政，井水不犯河水。而状态模式中的行为函数，首先是和状态主体之间存在着关联，由状态主体把它们串在一起；另一方面，正因为关联着同样的一个（或一类）主体，所以不同状态对应的行为函数可能并不会特别割裂。

#### 进一步改造

```javascript
class CoffeeMaker {
	constructor() {
		this.state = 'init'
		this.leftMilk = '500ml'
	}
	
	stateToProcessor = {
		that: this,
		american() {
			console.log('咖啡机现在的牛奶存储量是: ' + this.that.leftMilk)
      console.log('我只吐黑咖啡')
		},
		latte() {
      this.american()
      console.log('加点奶')
    },
    vanillaLatte() {
      this.latte()
      console.log('再加香草糖浆')
    },
    mocha() {
      this.latte()
      console.log('再加巧克力')
    }
	}
	
	changeState(state) {
		this.state = state
		if (!this.stateToProcessor[state]) {
			return
		}
		this.stateToProcessor[state]()
	}
}

const mk = new CoffeeMaker()
mk.changeState('latte')
```



### 状态模式之慕课网

#### 介绍

* 一个对象有状态变化
* 每次状态变化都会出发一个逻辑
* 不能总是用 if...else控制

#### 示例

交通信号灯不同颜色的变化

##### 传统 UML 类图

![image-20191109192810908](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191109192810908.png)

##### 简化 UML 类图

![image-20191109192847012](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191109192847012.png)

#### 代码

```javascript
class State {
	constructor(color) {
		this.color = color
	}
	
	handle(context) {
		console.log(`turn to ${this.color} light.`)
		context.setState(this)
	}
}
// 主体 
class Context {
	constructor() {
		this.state = null
	}
	
	getState() {
		return this.state
	}
	
	setState(state) {
		this.state = state
	}
}
```

使用

```javascript
let context = new Context()
let green = new State('green')
let yellow = new State('yellow')
let red = new State('red')

// 绿灯亮了
green.handle(context)
console.log(context.getState())
// 黄灯亮了
yellow.handle(context)
console.log(context.getState())
// 红灯亮了
red.handle(context)
console.log(context.getState())
```

#### 场景

##### 有限状态机

* 有限个状态、以及在这些状态之间的变化
* 如交通信号灯
* 推荐一个开源的 lib： javascript-state-machine

```javascript
import StateMachine from 'javascript-state-machine'

let fsm = new StateMachine({
  init: '收藏',
    transitions: [
    {
      name: 'doStore',
      from: '收藏',
      to: '取消收藏'
    },
    {
      name: 'deleteStore',
      from: '取消收藏',
      to: '收藏'
    }
  ],
  methods: {
    onDoStore() {
      alert('收藏成功')
      updateText()
    },
    onDeleteStore() {
      alert('取消收藏')
      updateText()
    }
  }
})

var $btn = $('#btn1')

$btn.click(function() {
  if (fsm.is('收藏')) {
    fsm.doStore()
  } else {
    fsm.deleteStore
  }
})

function updateText() {
  $btn.text(fsm.state)
}
// 初始化文案
updateText()
```



##### 写一个简单的 Promise

* 三种状态 pending fulfilled rejected
* pending=>fullfilled
* pending => rejected
* 不能逆向变化

```javascript
var fsm = new StateMachine({
	init: 'pending',
	transitions: [
		{
			name: 'resolve',
			from: 'pending',
			to: 'fulfilled'
		},
		{
			name: 'reject',
			from: 'pending',
			to: 'rejected'
		}
	],
	methods: {
		// 参数 state 当前状态
		// 参数 data 当前 MyPromise 的实例
		onResolve: function(state, data) {
			data.successList.forEach(fn => fn())
		},
		onReject: function(state, data) {
			data.failList.forEach(fn => fn())
		}
	}
})

class MyPromise {
	constructor(fn) {
		this.successList = []
		this.failList = []
		fn(function() {
      fsm.resolve(this)
    }, function() {
      fsm.reject(this)
    })
	}
	
	then(successFn, failFn) {
		this.successList.push(successFn)
		this.failList.push(failFn)
	}
}

function loadImg(src) {
  const promise = new MyPromise((resolve, reject) => {
    var img = document.createElement('img');
    img.onload = () => resolve(img)
    img.onerror = () => reject('load fail')
    img.src= src;
  });
  return promise;
}

let result = loadImg('https://www.baidu.com/img/bd_logo1.png')
result.then(img => {
  console.log('ok1');
},error => {
  console.log('fail1');
})
result.then(img => {
  console.log('ok2');
},error => {
  console.log(fail2);
})
```

##### 设计原则验证

* 将状态对象和主题对象分离，状态的变化逻辑单独处理
* 符合开放封闭原则



## 10 行为型：观察者模式

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 

观察者模式有一个“别名”，叫`发布 - 订阅模式`，因为观察者模式里两个核心的角色要素——**“发布者”**与**“订阅者”**。

角色划分 --> 状态变化 --> 发布者通知到订阅者，这就是观察者模式的“套路”。

首先我们来看这个代表发布者的类，我们给它起名叫Publisher。这个类应该具备哪些“基本技能”呢？大家回忆一下上文中的韩梅梅，韩梅梅的基本操作是什么？首先是拉群（增加订阅者），然后是@所有人（通知订阅者），这俩是最明显的了。此外作为群主&产品经理，韩梅梅还具有踢走项目组成员（移除订阅者）的能力。OK，产品经理发布者类的三个基本能力齐了，下面我们开始写代码：

```javascript
class Publisher {
	constructor() {
		this.observers = []
    console.log('Publisher created')
	}
	
	add(observer) {
  	console.log('Publisher.add invoked')
		this.observers.push(observer)
	}
	
	remove(observer) {
		console.log('Publisher.remove invoked')
		this.observers.forEach((item, i) => {
			if (item === observer) {
				this.observers.splice(i, 1)
			}
		})
	}
	
	notify() {
		console.log('Publisher.notify invoked')
		this.observers.forEach(observer => {
			observer.update(this)
		})
	}
}

class Observer {
	constructor() {
  	console.log('Observer created')
  }
  update() {
  	console.log('Observer.update invoked')
  }
}

class PrdPublisher extends Publisher {
	constructor() {
		super()
		this.prdState = null
		this.observers = []
		console.log('PrdPublisher created')
	}
	
	getState() {
		console.log('PrdPublisher.getState invoked')
		return this.prdState
	}
	
	setState(state) {
		console.log('PrdPublisher.setState invoked')
		this.prdState = state
		this.notify()
	}
}

class DeveloperObserver extends Observer {
	constructor() {
		super()
		this.prdState = {}
		console.log('DeveloperObserver created')
  }
  
  update(publisher) {
  	console.log('Observer.update invoked')
  	this.prdState = publisher.getState()
  	this.work()
  }
  
  work() {
  	const prd = this.prdState
  	console.log('996 begins...')
  }
}

// 创建订阅者：前端开发李雷
const liLei = new DeveloperObserver()
// 创建订阅者：服务端开发小A（sorry。。。起名字真的太难了）
const A = new DeveloperObserver()
// 创建订阅者：测试同学小B
const B = new DeveloperObserver()
// 韩梅梅出现了
const hanMeiMei = new PrdPublisher()
// 需求文档出现了
const prd = {
    // 具体的需求内容
}
// 韩梅梅开始拉群
hanMeiMei.add(liLei)
hanMeiMei.add(A)
hanMeiMei.add(B)
// 韩梅梅发送了需求文档，并@了所有人
hanMeiMei.setState(prd)
```

#### 考点

##### Vue数据双向绑定（响应式系统）的实现原理

在 Vue 中，每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式。

在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：

* observer，注意不是设计模式中的订阅者。observer 不仅是一个数据监听器，它还需要对监听到的数据进行**转发**——也就是说它**同时还是一个发布者**。
* watcher：observer 把数据转发给了**真正的订阅者**——watcher对象。watcher 接收到新的数据后，会去更新视图。
* compile：：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~

核心代码

```javascript
function observe(target) {
	if (target && typeof target === 'object') {
		Object.keys(target).forEach((key) => {
			defineReactive(target, key, target[key])
		})
	}
}

function defineReactive(target, key, val) {
	const dep = new Dep()
	observe(val)
	Object.defineProperty(target, key, {
		 // 可枚举
     enumerable: true,
     // 不可配置
     configurable: false, 
     get: function () {
       return val;
     },
     // 监听器函数
     set: function (value) {
       // 通知所有订阅者
       dep.notify()
     }
	})
}

// Dep 是订阅者
class Dep {
	constructor() {
		this.subs = []
	}
	
	notify() {
		this.subs.forEach((sub)=>{
      sub.update()
    })
	}
}
```

##### 实现一个 event bus 或者 event emitter

全局事件总线，严格来说不能说是观察者模式，而是发布-订阅模式。

所有事件的发布/订阅操作，必须经由事件中心，禁止一切“私下交易”！

```javascript
const EventBus = new Vue()
export default EventBus
```

在主文件里引入EventBus，并挂载到全局：

```javascript
import bus from 'EventBus的文件路径'
Vue.prototype.bus = bus
```

发布（触发）事件：

```javascript
this.bus.$emit('someEvent', params)
```

订阅事件：

```javascript
this.bus.$on('someEvent', func)
```



手写一个 event-bus

```javascript
class EventEmitter {
	constructor() {
		this.handlers = {}
	}
	
	on(eventName, cb) {
		if (!this.handlers[eventName]) {
			this.handlers[eventName] = []
		}
		this.handlers[eventName].push(cb)
	}
	
	emit(eventName, ...args) {
		if (this.handlers[eventName]) {
			this.handlers[eventName].forEach(cb => {
				cb(...args)
			})
		}
	}
	
	off(eventName, cb) {
		if (!cb) {
			delete this.handlers[eventName]
		} else {
			const callbacks = this.handlers[eventName]
			const index = callbacks.indexOf(cb)
			if (index !== -1) {
				callbacks.splice(index, 1)
			}
		}
		
	}
	
	// 为时间注册单次监听
	once(eventName, cb) {
		// 对回调函数进行包装，使其执行完毕自动被移除
		const wrapper = (...args) => {
			cb.apply(...args)
			this.off(eventName, wrapper)
		})
		this.on(eventName, wrapper)
	}
}
```



##### 观察者模式与发布-订阅模式的区别是什么？

回到我们上文的例子里。韩梅梅把所有的开发者拉了一个群，直接把需求文档丢给每一位群成员，这种**发布者直接触及到订阅者**的操作，叫观察者模式。但如果韩梅梅没有拉群，而是把需求文档上传到了公司统一的需求平台上，需求平台感知到文件的变化、自动通知了每一位订阅了该文件的开发者，这种**发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式**。

相信大家也已经看出来了，观察者模式和发布-订阅模式之间的区别，在于是否存在第三方、发布者能否直接感知订阅者。



但这并不意味着，发布-订阅模式就比观察者模式“高级”。在实际开发中，我们的模块解耦诉求**并非总是需要它们完全解耦**。如果两个模块之间本身存在关联，且这种关联是稳定的、必要的，那么我们使用观察者模式就足够了。而在模块与模块之间独立性较强、且没有必要单纯为了数据通信而强行为两者制造依赖的情况下，我们往往会倾向于使用发布-订阅模式。



## 11 行为型：迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》



在“公元前”，JS原生的集合类型数据结构，只有Array（数组）和Object（对象）；而ES6中，又新增了Map和Set。



ES6约定，任何数据结构只要具备Symbol.iterator属性（这个属性就是Iterator的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被for...of...循环和迭代器的next方法遍历。 事实上，for...of...的背后正是对next方法的反复调用。



```javascript
const arr = [1, 2, 3]
const len = arr.length
for(item of arr) {
    console.log(`当前元素是${item}`)
}
```



```javascript
const arr = [1, 2, 3]
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 对迭代器对象执行next，就能逐个访问集合的成员
iterator.next()
iterator.next()
iterator.next()
```

而for...of...做的事情，基本等价于下面这通操作：

```javascript
// 通过调用iterator，拿到迭代器对象
const iterator = arr[Symbol.iterator]()

// 初始化一个迭代结果
let now = { done: false }

// 循环往外迭代成员
while(!now.done) {
    now = iterator.next()
    if(!now.done) {
        console.log(`现在遍历到了${now.value}`)
    }
}
```

####  实现一个迭代器生成函数

```javascript
// 编写一个迭代器生成函数
function *iteratorGenerator() {
    yield '1号选手'
    yield '2号选手'
    yield '3号选手'
}

const iterator = iteratorGenerator()

iterator.next()
iterator.next()
iterator.next()
```

 ES5 实现

```javascript
function iteratorGenerator(list) {
	var len = list.length
	var index = 0
	return {
		next: function() {
			var done = index >=len
			var value = !done ? list[index++] : undefined
			return {
				done: done,
				value: value
			}
		}
	}
}

var it = iteratorGenerator([1, 2,3])
console.log(it.next())
console.log(it.next())
console.log(it.next())
console.log(it.next())
```



## 12





## 其他设计模式（用得少）

### 原型模式

#### 概念

* clone 自己，生成一个新对象
* java 默认有 clone 接口，不用自己实现
* Object.create 用到了原型模式的思想，基于一个原型，创建一个对象

```javascript
var prototype = {
	first: 'undefined',
	last: 'undefined',
	getName: function() {
		return this.first + ' ' + this.last
	},
	say: function() {
		console.log('hello, I am ' + this.getName())
	}
}

var x = Object.create(prototype)
x.first = 'A'
x.last = 'B'
console.log(x.getName())
x.say()
var y = Object.create(prototype)
y.first = 'C'
y.last = 'D'
console.log(y.getName())
y.say()
 ```

#### 对比 JS 中的原型 prototype

* prototype 可以理解为 ES6 class 的一种底层原理

* 而 class 是实现面向对象的基础，并不是服务于某个模式 

* 若干年后 ES6 全面普及，大家可能会忽略掉 prototype

* 但是 Object.create 却会长久存在

  

### 桥接模式

#### 概念

* 用于把抽象化与实现化解耦
* 使得二者可以独立变化

#### 示例

![image-20191110161648910](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191110161648910.png)



不好的代码

```javascript
class ColorShape {
	yellowCircle() {
		console.log('yellow circle')
	}
	redCircle() {
		console.log('red circle')
	}
	yellowTriangle() {
		console.log('yellow triangle')
	}
	redTriangle() {
		console.log('red triangle')
	}
}

let cs = new ColorShpae()
cs.yellowCircle()
cs.redCircle()
cs.yellowTriangle()
cs.redTriangle()
```

![image-20191110162042544](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191110162042544.png)

桥接模式

```javascript
class Color {
	constructor(name) {
		this.name = name
	}
}

class Shape {
	constructor(name, color) {
		this.name = name
		this.color = color
	}
	draw() {
		console.log(`${this.color.name} ${this.name}`)
	}
}

let red = new Color('red')
let yellow = new Color('yellow')
let circle = new Shape('circle', red)
circle.draw()
let triangle = new Shape('triangle', yellow)
triangle.draw()
```


#### 设计原则验证

* 抽象和实现的分离，解耦
* 开放封闭原则



### 组合模式

#### 概念

* 生成树形结构，表示“整体-部分”的关系
* 让整体和部分都具有一致的操作方式
* 例如文件系统树
* JS 经典应用中，未找到这么复杂的数据结构
* 虚拟 DOM 中的 vnode 是这种形式，但是数据类型简单
* 用 JS 实现一个菜单，不算经典应用，与业务相关

#### 演示

```javascript
<div id="div1" class="container">
	<p>123</p>
	<p>456</p>
</div>
```

```javascript
{
	tag: 'div',
	attr: {
		id: 'div1',
		className: 'container'
	},
	children: [
		{
			tag: 'P',
      attr: {},
      children: ['123']
		},
		{
			tag: 'P',
      attr: {},
      children: ['456']
		}
	]
}
```

#### 总结

* 整体和单个节点的操作是一致的
* 整体和单个节点的数据结构也保持一致

#### 设计原则验证

* 将整体和单个节点的操作抽象出来
* 符合开放封闭原则

### 享元模式

* 共享、元素局

#### 概念

* 共享内存（主要考虑内存，而非效率）
* 相同的数据，共享使用
* JS 中未找到经典应用场景

### 示例

无限下拉别表，将时间代理到高层节点上

如果绑定到 a 标签，对内存开销太大

实际上是个代理模式的例子，但是它体现了享元模式的思想

```javascript
<div id="div1">
	<a href="#">a1</a>
	<a href="#">a2</a>
	<a href="#">a3</a>
	<a href="#">a4</a>
</div>

<script>
	var div1 = document.getElementById('div1')
	div1.addEventListener('click', function(e) {
		var target = e.target
		if (e.nodeName === 'A') {
			alert(target.innerHTML)
		}
	})
</script>
```

#### 设计原则验证

* 将相同的部分抽象出来
* 符合开放封闭原则
* 共享的数据，不同的地方不一样的话，不用享元模式，需要使用装饰器模式，适配器模式，代理模式



### 模板方法模式

对内部的特殊处理，可以把它封装成一个方法对外输出

```javascript
class Action {
	handle() {
		handle1()
		hander2()
		handle3()
	}
	handle1() {
		console.log('1')
	}
	handle2() {
		console.log('2')
	}
	handle3() {
		console.log('3')
	}
}
```



### 职责链模式

#### 概念

* 一步操作可能分配多个职责角色来完成 
* 把这些角色都分开， 然后用一个链穿起来
* 将发起者和各个处理者进行隔离
* 发起者和处理者，各个处理者之间进行隔离

#### 示例

```javascript
class Action {
	constructor(name) {
		this.name = name
		this.nextAction = null
	}
	setNextAction(action) {
		this.nextAction = action
	}
	handle() {
		console.log(`${this.name}审批`)
		if (this.nextAction !== null) {
			this.nextAction.handle()
		}
	}
}

let a1 = new Action('组长')
let a1 = new Action('经理')
let a1 = new Action('总监')

a1.setNextAction(a2)
a2.setNextAction(a3)

a1.handle()
```

#### JS  中的链式操作

* 职责链模式和业务结合较多，JS 中能联想到链式操作
* Node 中 stream 的 pipe，Promise.then

#### 设计模式验证

* 发起者与各个处理者进行隔离
* 符合开放封闭原则

### 命令模式

#### 概念

* 执行命令时，发布者和执行者分开
* 中间加入命令对象，作为中转站
* 类似于打仗的时候，统帅下达命令给打鼓的，打鼓的一打鼓，全军收到命令了 
* 发布者和接受者不能直接接触的时候可以用

![image-20191114125450072](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191114125450072.png)

#### 示例

```javascript
class Receiver {
	exec() {
		console.log('执行')
	}
}

class Command {
	constructor(receiver) {
		this.receiver = receiver
	}
	cmd() {
		console.log('触发命令')
		this.receiver.exec()
	}
}

class Invoker {
	constructor(command) {
		this.command = command
	}
	invoke() {
		console.log('开始')
		this.command.cmd()
	}
}

let soldier = new Receiver() // 士兵
let trumpeter = new Command(solider) // 小号手
let general = new Invoker(trumpeter) // 将军
general.invoke()
```

#### JS 中的应用

* 网页富文本编辑器，浏览器封装了一个命令对象
* document.execCommand('bold')
* document.execCommand('undo')

#### 设计模式验证

* 命令对象与执行对象分开，解耦
* 符合开放封闭原则



### 备忘录模式

#### 概念

* 随时记录一个对象的状态变化
* 随时可以恢复之前的某个状态（如撤销功能）
* 未找到 JS 中经典应用，除了一些工具（如编辑器）

#### 演示

```javascript
// 状态备忘
class Memento {
	constructor(content) {
		this.content = content
	}
	
	getContent() {
		return this.content
	}
}

// 备忘录列表
class CareTaker {
	constructor() {
		this.list = []
	}
	add(memento) {
		this.list.push(memento)
	}
	get(index) {
		return this.list[index]
	}
}

class Editor {
	constructor() {
		this.content = null
	}
	setContent(content) {
		this.content = content
	}
	getContent() {
		return this.content
	}
	saveContentToMemento() {
		return new Memento(this.content)
	}
	getContentFromMemento(memento) {
		this.content = memento.getContent()
	}
}

let editor = new Editor()
let careTaker = new CareTaker()
editor.setContent('111')
editor.setContent('222')
careTaker.add(editor.saveContentToMemento())
editor.setContent('333')
careTaker.add(editor.saveContentToMemento())
editor.setContent('444')
console.log(editor.getContent())
editor.getContentFromMemento(careTaker.get(1))
console.log(editor.getContent())
editor.getContentFromMemento(careTaker.get(0))
console.log(editor.getContent())
```

#### 设计原则验证

* 状态对象与使用者分开，解耦
* 符合开放封闭原则



### 中介者模式

#### 概念

![image-20191119124354169](/Users/lvjiawen/Library/Application Support/typora-user-images/image-20191119124354169.png)

#### 演示

```javascript
class Mediator {
	constructor(a, b) {
		this.a = a
		this.b = b
	}
	setA() {
		let number = this.b.number
		this.a.setNumber(number*100)
	}
	setB() {
		let number = this.a.number
		this.b.setNumber(number / 100)
	}
}
// 买房者，A 和 B
class A {
	constructor() {
		this.number = 0
	}
	setNumber(num, m) {
		this.number = num
		// 如果有中介者，通过中介者去修改 B
		if (m) {
			m.setB()
		}
	}
}

class B {
	constructor() {
		this.number = 0
	}
	setNumber(num, m) {
		this.number = num
		if (m) {
			m.setA()
		}
	}
}

let a = new A()
let b = new B()
let m = new Mediator(a, b)
a.setNumber(100, m)
console.log(a.number, b.number)
b.setNumber(100, m)
console.log(a.number, b.number)
```

#### 设计原则验证

* 将各个关联对象通过中介者隔离
* 符合开放封闭原则



### 访问者模式

* 将数据操作和数据结构进行分离
* 使用场景不多

### 解释器模式

* 描述语言语法如何定义，如何解释和编译
* 用于专业场景